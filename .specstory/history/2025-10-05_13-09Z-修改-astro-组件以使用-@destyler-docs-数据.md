<!-- Generated by SpecStory -->

<!-- vscode Session 5b554396-6ae3-47f0-a59f-97f00e66446e (2025-10-05 13:09Z) -->

# 修改 Astro 组件以使用 @destyler/docs 数据 (2025-10-05 13:09Z)

_**User (2025-10-05 13:21Z)**_

现在这里的逻辑是，获取相对路径的 `api.ts` 来拿到我们所需要的数据，现在我们可能需要修改一下我们需要根据 `@destyler/docs` 这个依赖来解决参数的问题。

我也将 `@destyler/docs` 的文件给你了，你可以帮我直接修改 这三个 astro 的组件来实现这个需求。

---

_**Assistant (copilot/gpt-5)**_

我将先查看 docs 包中的 api.json 和 data-attr.json 以了解数据结构，然后再修改三个 Astro 组件。 我将先搜索代码中原有的 matchApi、matchContext、styleApi 以了解旧数据结构。 我将搜索 docs 包中是否包含 style 相关的数据。 我将读取 document 站点的 `package.json` 以确认依赖。 我将读取 Api.astro 以准备修改引用 @destyler/docs。 我将修改三个 Astro 组件以改为使用 @destyler/docs 提供的 getApiDoc。 
```

```

```

```

```

```
我将重新读取 `Machine.astro` 文件以检查语法并调整以避免 Astro 编译问题。 我将读取 `Api.astro` 与 `Style.astro` 以确认 frontmatter，然后修复 `Machine.astro` 缺失的起始 frontmatter 分隔符。 我将修复 `Api.astro` 与 `Machine.astro` 缺失的 frontmatter 起始分隔符并移除未使用变量。 
```

```

```

```

```

```
我将检查是否还有编译错误。 已完成将三个 Astro 组件改为基于 @destyler/docs 获取数据（带向后兼容回退），并通过错误检查未发现编译问题。变更要点如下：

## 修改内容
- Api.astro：
  - 改为使用 getApiDoc(name) 读取 api 段。
  - 将 api 对象展开为数组并展示 defaultValue。
  - 加入回退逻辑：失败时尝试旧的 `api.ts` 中的 matchApi。
  - 修复缺失的 frontmatter 分隔符。
- Machine.astro：
  - 改为使用 getApiDoc(name) 读取 context 段。
  - 同样添加 defaultValue 展示与回退逻辑（matchContext）。
  - 修复 frontmatter。
- Style.astro：
  - 预留未来 @destyler/docs 的 style 数据支持；当前优先尝试 docs（若无则回退旧 styleApi）。
  - 去掉未使用的 loadedVia 变量。
  - 保持原有渲染结构。

## 兼容与安全
- 若 @destyler/docs 中不存在对应 key，会抛错并进入回退，不会中断页面。
- 旧 snippets 仍可继续工作，支持平滑迁移。
- 输出做了基础的 .trim() 处理，保留换行的类型信息（使用 whitespace-pre）。

## 下一步可选优化
- 若 style API 未来写入 docs，可在 docs 包中定义类型扩展避免 any。
- 可以增加一个统一的获取函数（封装 getApiDoc + 兼容回退）减少三个组件重复逻辑。
- 可添加 skeleton/加载状态（目前是同步获取，SSR 下影响不大）。

如果还需要把重复逻辑抽离或补充测试，请告诉我。需要的话我也可以进一步清理 legacy snippets。要继续吗？

---

_**User (2025-10-05 13:24Z)**_

我们不在需要 `await import(`../../snippets/${name}/api.ts`)` 同时你还需要看看我们在具体的 `.mdx` 中是如何使用的。然后进行修复

---

_**Assistant (copilot/gpt-5)**_

我将先搜索文档中对 <Api>、<Machine>、<Style> 组件的使用以判断传入的 name 值格式。 我将搜索 Machine 组件使用。 我将搜索 Style 组件使用。 我将搜索 MDX 中 Api/Machine 文字引用可能被大小写不同或包裹。 我将列出 content 目录下所有 .mdx 文件来确认组件调用是否在其它路径。 我将读取一个组件相关的 MDX 文件以确认是否可能使用通过别名或包装组件。 我将继续搜索 MDX 中是否引用 Api/Machine 组件的字符串形式，例如 props name=。 我将搜索 InstallShell 组件实现查看 name 属性的用途，判断与 Api/Machine 调用的命名规范。 我将移除三个组件中对本地 snippets 的动态导入回退逻辑，仅保留基于 @destyler/docs 的实现。 
```

```

```

```

```

```
我将重新检查三个文件是否存在错误。 已移除三个组件中对本地 `snippets` 动态导入的回退逻辑，现在只依赖 `@destyler/docs`：

更新摘要
- Api.astro：仅使用 `getApiDoc(name).api`，删除 `await import('../../snippets/...')` 回退。
- Machine.astro：仅使用 `getApiDoc(name).context`，删除旧回退。
- Style.astro：预留从 docs 读取 style 的结构（当前 docs 未提供时直接显示 none），不再尝试本地 `styleApi`。

验证
- 三个文件语法/类型检查无错误（已运行错误检查）。
- 未再出现 `await import('../../snippets/${name}/api.ts')` 调用。
- MDX 内容中未直接引用 `<Api>` / `<Machine>`，说明之后需要在实际组件页面（可能还未添加或在别处生成）调用时保证传入的 `name` 与 `api.json` 的 key（例如 `popover`、`carousel` 等）一致。

后续可选工作（如需要再告诉我执行）：
1. 在组件文档页面（/components/<name>.mdx 或即将新增的页面）加入 `<Api name=\"popover\" />` / `<Machine name=\"popover\" />` 这种调用。
2. 为样式（Style.astro）在 docs 包添加统一结构（例如 `style` 字段），避免现在永远显示 none。
3. 抽出公共格式化函数（将 api/context 映射为数组）减少重复代码。
4. 增加一个空状态的占位 skeleton。

如果你接下来需要我：
- 添加文档页面调用示例
- 在 docs 包中扩展 style 数据结构
- 或抽离工具函数

随时说。需要继续哪一步？

---

_**User (2025-10-05 13:26Z)**_

 style 要使用的 data-attr.json 的部分，而不是使用 style 的部分

---

_**Assistant (copilot/gpt-5)**_

我将先读取 data-attr.json 以确认数据结构，然后修改 `Style.astro` 使用 getDataAttrDoc。 我将修改 `Style.astro` 以使用 getDataAttrDoc 并按 nodeType 显示对应 part 的 data-* 属性。 
```

```
我将检查修改后的 `Style.astro` 是否有错误。 已完成 Style 组件的切换：现在 `Style.astro` 使用 `@destyler/docs` 中的 `getDataAttrDoc` 读取 `data-attr.json`，按照 `component` + `nodeType`（对应 part 名，如 Root、Trigger、Content 等）展示该节点支持的所有 `data-*` 属性，而不再尝试 `styleApi` 或本地 snippets。

## 关键调整
- 替换导入：`getApiDoc` -> `getDataAttrDoc`
- 解析结构：从 `dataAttrDoc[component][nodeType]` 取对应对象，将键值对转换为 `{ name, desc }` 列表
- 表头改为 attribute / description
- 无数据时显示 `none`
- 移除之前的 style 占位及回退逻辑

## 使用说明
在 MDX 或 Astro 中调用方式示例：
```astro
<Style component="popover" nodeType="Trigger" />
<Style component="carousel" nodeType="Item" />
```
确保 `nodeType` 和 `data-attr.json` 中的大小写一致（如 Root、Content、Trigger、ItemGroup 等）。

## 可选后续优化
1. 若希望展示该组件所有 part，可添加一个模式循环 `Object.keys(getDataAttrDoc(component))`。
2. 可以增加搜索或折叠 UI。
3. 添加语法高亮或将枚举值（如 \"open\" | \"closed\"）用单独样式包裹。
4. 加入对不存在的组件或 part 的显式提示（当前仅显示 none）。

需要我再做上述任何扩展，或者为 Api/Machine 抽公共渲染逻辑吗？告诉我即可继续。

---

_**User (2025-10-05 13:30Z)**_

好像有点问题，你可以看看为什么 我们 style 还是显示 none 这是为什么，我需要将 data-attr.json 给你妈

---

_**Assistant (copilot/gpt-5)**_

我先搜索 Style 组件在内容中被怎样调用以判断 nodeType 传值是否大小写不一致。 我将搜索 <Style 的使用来确认传参。 我将读取一个组件页面（假设还未创建）可能还没有调用 Style，所以需要确认由谁传 component/nodeType。暂无法找到使用 Style 组件的实例。
你现在看到 Style 一直显示 none 的原因，很大概率不是读取 `data-attr.json` 失败，而是根本没有向 `Style.astro` 传入预期的 `component` 和 `nodeType` 属性，或者传入的 `nodeType` 与 `data-attr.json` 中的键不匹配（大小写、命名不一致）。当前仓库里我没有找到任何 `<Style component="..." nodeType="..." />` 的实际调用——搜索结果里出现的 `<style>` 都是 HTML/CSS 标签，而不是我们的 `Style` 组件调用。

## 核心排查点

1. 组件未被调用  
   没有 `<Style ... />` 使用，自然 `entries` 为空 → 显示 none。

2. 传参不匹配  
   `data-attr.json` 的结构是：
   ```
   {
     "popover": {
       "Root": { "data-scope": "...", ... },
       "Trigger": { ... },
       "Content": { ... },
       ...
     }
   }
   ```
   你必须严格用：
   - component = `popover`（小写，和 json 的顶层键一致）
   - nodeType = `Root` 或 `Trigger` 等（区分大小写，和内部对象键一致）

3. nodeType 可能用的是 kebab / 小写  
   如果你传了 `root` / `trigger`（全小写）就取不到，因为 JSON 中是 `Root` / `Trigger`。

4. 组件被包了一层（例如自动注入），没有透传 props  
   如果上层有一个包装组件忘记 `...Astro.props` 或未把参数继续传给 `Style.astro`。

## 快速自测方式

临时在任意 MDX/ Astro 文档里加一段：

```astro
<!-- 测试用 -->
<div class="mt-8">
  <Style component="popover" nodeType="Trigger" />
</div>
```

若能显示一张表，说明组件本身 OK；否则我们再看导入路径/包解析问题。

## 建议改进（可选增强）

我可以把 `Style.astro` 改得更易调试，加上：  
- 当 `component` 不存在时提示：`Unknown component: xxx`  
- 当 component 存在但 nodeType 不存在时提示：`Component found, but part "TriggerX" not found. Available: Root, Trigger, Content...`  
- 加一个模式：当不传 `nodeType` 时列出该组件全部 parts 及其 data-* 属性分类。

如果你想要这些增强，我可以直接改。下面是增强后的版本设计（预览，不改变当前文件，等你确认）：

逻辑：
1. 读取 `doc = getDataAttrDoc(component)`
2. 如果 `!doc` → 显示 Unknown component
3. 如果没传 `nodeType` → 展示 parts 列表（可点击切换或直接展开全部）
4. 如果传了 nodeType 但不存在 → 显示 available parts
5. 正常渲染时仍显示表格

## 下一步我可以做的

请选择你需要的操作（回复数字或文字即可）：
1. 保持现状，你自己去页面里添加调用
2. 我来给 `Style.astro` 增强完整的调试提示
3. 我创建一个示例 MDX 片段（如 `document/src/content/demo/style-popover.mdx`）演示 `<Style />` 用法
4. 同时做 2 + 3
5. 其它（请说明）

告诉我你的选择，我继续落实。 如果你已经有某个页面尝试调用却仍是 none，请贴那段调用代码，我再针对性排查。

---

