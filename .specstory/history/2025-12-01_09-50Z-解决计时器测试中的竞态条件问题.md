<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- vscode Session 754f7751-de80-4040-8777-77c092520676 (2025-12-01 09:50Z) -->

# 解决计时器测试中的竞态条件问题 (2025-12-01 09:50Z)

_**User (2025-12-01 09:51Z)**_

现在 #file:timer.spec.ts 偶尔会出现这个错误

```
 ❯  browser (chromium)  packages/components/timer/test/timer.spec.ts (5 tests | 1 failed) 32451ms
     ✓ renders countdown segments and area metadata 13ms
     ✓ auto starts countdown and updates aria label as seconds elapse  1106ms
     × pause halts countdown until resume continues ticking 29973ms
     ✓ reset while paused restores the start value and returns to idle controls 110ms
     ✓ start restarts the timer after resetting to idle  1249ms

⎯⎯⎯⎯⎯⎯⎯ Failed Tests 1 ⎯⎯⎯⎯⎯⎯⎯

 FAIL   browser (chromium)  packages/components/timer/test/timer.spec.ts > [timer] browser tests > pause halts countdown until resume continues ticking
Error: expect(element).toHaveTextContent()

Expected element to have text content:
  09
Received:
  08

Failure screenshot:
  - packages/components/timer/test/__screenshots__/timer.spec.ts/-timer--browser-tests-pause-halts-countdown-until-resume-continues-ticking-1.png

 ❯ packages/components/timer/test/timer.spec.ts:61:48
```

---

_**Agent (model copilot/claude-opus-4.5)**_

<tool-use data-tool-type="read" data-tool-name="copilot_readFile">
<details>
<summary>Tool use: **copilot_readFile** • 正在读取 [](file:///Users/elonehoo/Developer/destyler-dev/destyler/packages/components/timer/examples/vanilla/Timer.ts)</summary>


读取 [](file:///Users/elonehoo/Developer/destyler-dev/destyler/packages/components/timer/examples/vanilla/Timer.ts)

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="copilot_replaceString">
<details>
<summary>Tool use: **copilot_replaceString**</summary>

Additional data:

```json
{
  "vscodeToolId": "copilot_replaceString",
  "isHidden": true
}
```
Result:

```json
{
  "invocationMessage": "正在使用 \"替换文件中的字符串\"",
  "isConfirmed": {
    "type": 1
  },
  "content": "&#96;&#96;&#96;typescript\n  it('pause halts countdown until resume continues ticking', async () =&gt; {\n    await waitForNextSecond()\n\n    // Capture the current seconds value before pausing\n    const secondsElement = timerItem('seconds').element()\n    const secondsBeforePause = secondsElement.textContent\n\n    await userEvent.click(actionTrigger('pause'))\n    await expect.element(actionTrigger('resume')).not.toHaveAttribute('hidden', '')\n\n    // Wait and verify the value hasn't changed while paused\n    await waitForNextSecond()\n    await expect.element(timerItem('seconds')).toHaveTextContent(secondsBeforePause!)\n\n    await userEvent.click(actionTrigger('resume'))\n    await waitForNextSecond()\n\n    // After resuming and waiting, the value should have decremented by 1\n    const expectedAfterResume = String(Number(secondsBeforePause) - 1).padStart(2, '0')\n    await expect.element(timerItem('seconds')).toHaveTextContent(expectedAfterResume)\n  })\n&#96;&#96;&#96;\n\n",
  "textEditContent": "  it('pause halts countdown until resume continues ticking', async () =&gt; {\n    await waitForNextSecond()\n\n    // Capture the current seconds value before pausing\n    const secondsElement = timerItem('seconds').element()\n    const secondsBeforePause = secondsElement.textContent\n\n    await userEvent.click(actionTrigger('pause'))\n    await expect.element(actionTrigger('resume')).not.toHaveAttribute('hidden', '')\n\n    // Wait and verify the value hasn't changed while paused\n    await waitForNextSecond()\n    await expect.element(timerItem('seconds')).toHaveTextContent(secondsBeforePause!)\n\n    await userEvent.click(actionTrigger('resume'))\n    await waitForNextSecond()\n\n    // After resuming and waiting, the value should have decremented by 1\n    const expectedAfterResume = String(Number(secondsBeforePause) - 1).padStart(2, '0')\n    await expect.element(timerItem('seconds')).toHaveTextContent(expectedAfterResume)\n  })",
  "toolCallResult": null
}
```
Status: **completed**


</details>
</tool-use>

---

这个测试失败是由于 **竞态条件 (race condition)** 导致的。问题在于测试开始时计时器已经自动启动，在 `waitForNextSecond()` 等待期间，计时器可能已经走了不止一秒。

让我先查看一下测试的 render 函数，了解计时器的初始配置： 问题很清楚了。计时器配置了 `autoStart: true`，这意味着计时器在渲染时立即开始倒计时。测试中的竞态条件是：

1. 计时器从 10 秒开始自动倒计时
2. 第一个 `waitForNextSecond()` 等待 1100ms
3. 但在这 1100ms 内，计时器可能已经从 10 跳到 9，甚至继续跳到 8
4. 当测试断言秒数为 `09` 时，它可能已经是 `08` 了

**解决方案**：测试应该在点击暂停前先记录当前的秒数值，然后验证暂停后值不变，而不是假设一个固定的值。 修改完成。现在测试不再依赖固定的秒数值，而是：

1. **暂停前捕获当前秒数** - 不管计时器走到哪里，都记录当前值
2. **验证暂停期间值不变** - 确保暂停真的生效了
3. **验证恢复后值递减** - 根据暂停前捕获的值计算预期值

这样测试就不会因为计时器的时机差异而出现偶发失败了。

---

