<!-- Generated by SpecStory -->

<!-- vscode Session 9aeda0ca-2875-46b6-8b6a-59d04d3a2dae (2025-10-17 13:03Z) -->

# 在 Lit 中实现类似 React 的状态管理 (2025-10-17 13:03Z)

_**User (2025-10-17 13:18Z)**_

你可能需要帮我修改一下 `packages/frameworks/lit` 的实现，让我有类似 React 的体验。

我想使用类似的 api 方式

```ts
import { html, unsafeCSS } from "lit"
import { customElement } from "lit/decorators.js"
import * as accordion from "@destyler/accordion"
import { accordionControls, accordionData } from "@destyler/shared"
import styleComponent from "@destyler/shared/src/css/accordion.css?inline"
import styleLayout from "@destyler/shared/src/css/layout.css?inline"
import stylePage from "./page.css?inline"
import { MachineController, normalizeProps, spread } from "@destyler/lit"
import { ArrowRight, createElement } from "lucide"
import { nanoid } from "nanoid"
import { ControlsController } from "../lib/controls-controller"
import { PageElement } from "../lib/page-element"

@customElement("accordion-page")
export class AccordionPage extends PageElement {
  static styles = unsafeCSS(styleComponent + styleLayout + stylePage)

  private controls = new ControlsController(this, accordionControls)
  private machineId = nanoid(5)

  private machine = new MachineController(this, accordion.machine({
    getRootNode: () => this.shadowRoot || this.ownerDocument,
    id: this.machineId,
    ...this.controls.context,
  }))

  render() {
    const api = accordion.connect(this.machine.service, normalizeProps)

    return html`
      <main class="accordion">
        <div ${spread(api.getRootProps())}>
          ${accordionData.map(
            (item) => html`
              <div ${spread(api.getItemProps({ value: item.id }))}>
                <h3>
                  <button data-testid="${item.id}:trigger" ${spread(api.getItemTriggerProps({ value: item.id }))}>
                    ${item.label}
                    <div ${spread(api.getItemIndicatorProps({ value: item.id }))}>${createElement(ArrowRight)}</div>
                  </button>
                </h3>
                <div data-testid="${item.id}:content" ${spread(api.getItemContentProps({ value: item.id }))}>
                  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et
                  dolore magna aliqua.
                </div>
              </div>
            `,
          )}
        </div>
      </main>
      <destyler-toolbar .controls=${this.controls}>
        <destyler-state-visualizer .state=${this.machine.service}></destyler-state-visualizer>
      </destyler-toolbar>
    `
  }
}
```

---

_**Assistant (copilot/gpt-5)**_

我会先浏览仓库中 `` 的现有实现，找出缺失的 API（例如 MachineController、normalizeProps、spread 指令等），并评估需要新增或调整的文件。随后我会补齐这些能力并验证类型与构建是否通过。 我会新增一个 `MachineController` 实现为 Lit 的 ReactiveController，以便像 React 一样使用服务和状态；随后导出它并做一次类型检查。 
```

```

```

```

```

```

```

```

```

```

```

```
我先为 Lit 框架补齐了你示例里期望的“React 风格”能力，重点是提供一个 MachineController，方便在 Lit 组件里像 React 的 useMachine 一样管理状态与发送事件。

## 这次我做了什么
- 新增 MachineController（Lit ReactiveController）
  - 文件: `machine-controller.ts`
  - 功能:
    - 接受 `Machine` 或工厂函数，按需注入初始 `context/actions/state`。
    - 生命周期内自动执行 `_created()`、`start()`、`stop()`。
    - 订阅机器 state 变化，自动触发 `host.requestUpdate()`，保持 Lit 组件渲染更新。
    - 暴露 `state`、`send`、`service`，与 React 的 `[state, send, service]` 使用体验一致。
    - 支持 `setOptions` 动态注入 `actions/context`。
- 对外导出
  - 在 `index.ts` 导出了 `MachineController`。
  - 现有 `normalizeProps` 和 `spread` 指令已经支持你的用法；保持不变并继续导出。
- 类型/构建自检
  - 对新增与调整文件做了类型检查（本地无报错）。
  - 修正了若干 import 顺序与 type-only import 的 lint 要求。

## 如何在 Lit 中使用
你可以在 Lit 组件里这样写（与 React 用法很接近）：

- 若组件库的 `connect` 接口是常见签名 `(state, send, normalize)`：
  - 推荐写法：
    - `const api = accordion.connect(this.machine.state, this.machine.send, normalizeProps)`
- 如果你的 `connect` 已支持直接传入 `service`（正如你示例里的写法）：
  - `const api = accordion.connect(this.machine.service, normalizeProps)`

示例（核心片段，与你提供的一致，仅在 connect 传参上给两种写法任选其一）：
- 初始化
  - `private machine = new MachineController(this, accordion.machine({...}))`
- 渲染
  - A. 经典签名（兼容当前本仓库大部分组件）
    - `const api = accordion.connect(this.machine.state, this.machine.send, normalizeProps)`
  - B. 你示例的签名（若该组件实现支持）
    - `const api = accordion.connect(this.machine.service, normalizeProps)`

既有的 `spread` 指令和 `normalizeProps` 已经满足：
- `normalizeProps` 会把 React 风格事件名映射为 Lit 事件（如 `onClick` -> `@click`），并处理布尔属性、style 对象、children 等。
- `spread` 用来把归一化后的属性一把挂到元素上，正如你的模板示例。

## 邻接小优化（可选）
- 如果你想在不改组件库 `connect` 的前提下，也能用“传 service”的方式，我们可以在 `@destyler/lit` 里加一个小适配器（例如 `connectService(connectFn, service, normalize)`），这样你可以写：
  - `const api = connectService(accordion.connect, this.machine.service, normalizeProps)`
- 目前我没有默认加这个适配器，避免引入新的公共 API；如果你觉得有用，我可以补上。

## 质量门（变更影响范围内）
- Build: PASS（新增与修改文件类型检查通过；包内构建命令未见错误输出）
- Lint/Typecheck: PASS（修复了 import 顺序与 type-only import）
- Tests: 本包未发现相关用例，N/A

## 小结
- 新增 `MachineController` 并导出，现已支持在 Lit 里以“React 风格”的方式管理状态与渲染更新。
- 现有 `normalizeProps` 与 `spread` 已与你的使用示例完全对齐。
- 若需要，我可以继续把某个 Lit 示例（如 `AspectRatio.ts`）切换到 `MachineController` 的写法，或添加 `connectService` 适配器，告诉我你的偏好即可。

---

_**User (2025-10-17 13:19Z)**_

那你尝试在这里演示一下

---

_**Assistant (copilot/gpt-5)**_



---

