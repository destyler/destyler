<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- vscode Session 77656133-1476-4356-993c-f7a9850c7ef2 (2025-10-17 12:22Z) -->

# Lit 组件实现与使用示例 (2025-10-17 12:22Z)

_**User (2025-10-17 12:51Z)**_

我想给 lit 实现一个这三个组件，你就编写在 `shared/src/lit` 中，我希望组件是这么用的

```ts
<destyler-toolbar .controls=${this.controls}>
        <destyler-state-visualizer .state=${this.machine.service}></destyler-state-visualizer>
      </destyler-toolbar>
```

我喜欢 hook 是这样的

```ts
private controls = new ControlsController(accordionControls)
```

---

_**Agent (model copilot/gpt-5)**_

我将先浏览仓库以确认是否已有 lit 相关结构或依赖，然后在 `` 下创建三个文件：`components/toolbar.ts`, `components/state-visualizer.ts`, 以及 `controllers/controls-controller.ts`，并导出它们以便使用。随后我会检查类型和构建是否通过。 我将创建 Lit 版本的三个实体：`destyler-toolbar`、`destyler-state-visualizer` 组件和 `ControlsController` 控制器，并在 `index.ts` 中导出它们，便于直接使用与集成。 
```

```

```

```
我将添加 ControlsController 类和 Toolbar 组件到 Lit 目录，并更新导出，以便你能按要求使用它们并处理订阅与渲染。 
```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```

```
我来把 Lit 版本的这三个能力补齐了：`destyler-toolbar`、`destyler-state-visualizer` 组件，以及一个可在 Lit 中使用的 `ControlsController`，并已在 `index.ts` 导出，按你希望的 API 使用即可。

我已创建并接好以下内容：
- 组件
  - `StateVisualizer.ts`：Lit 版可视化组件，和 React 版一致，内部用 `@destyler/stringify` 的 `highlightState` 渲染状态。
  - `Toolbar.ts`：Lit 版工具条，和 React 版结构一致，支持 Controls / Visualizer 两个 tab，`controls` 为可选。
- 控制器（hook）
  - `ControlsController.ts`：Lit 下的控制器，等价于你喜欢的 hook，用法是 `new ControlsController(accordionControls)`。它内部管理状态、订阅、并能渲染控制 UI。

如何使用
- 在 Lit 组件里：
  - 初始化 hook（控制器）
    - `private controls = new ControlsController(accordionControls)`
  - 在模板中使用组件
    - 
      <destyler-toolbar .controls=${this.controls}>
        <destyler-state-visualizer .state=${this.machine.service}></destyler-state-visualizer>
      </destyler-toolbar>
- 你也可以传 `viz` 属性控制默认显示的是 Visualizer：

  <destyler-toolbar .controls=${this.controls} viz>
    <destyler-state-visualizer .state=${this.machine.service}></destyler-state-visualizer>
  </destyler-toolbar>

文件清单
- `StateVisualizer.ts`
  - Props:
    - state: any
    - label?: string
    - omit?: string[]
  - 功能：渲染打开的 details，summary 默认 “Visualizer”，内容用 highlightState + unsafeHTML。
- `Toolbar.ts`
  - Props:
    - viz?: boolean（默认 false）
    - controls?: ControlsController
  - 行为：若传入 controls，则显示 Controls/Visualizer 两个 tab；否则只显示 Visualizer，Slot 内容用于放 Visualizer。
  - 会对 controls.subscribe 做订阅，触发 requestUpdate，避免多次订阅已做清理。
- `ControlsController.ts`
  - API:
    - constructor(config: ControlRecord)
    - context getter：返回当前状态对象
    - setState(key, value)
    - getState(key)
    - keys: string[]（config 的键）
    - subscribe(fn): 取消订阅函数
    - render(): TemplateResult（可直接在 Lit 模板中嵌入）
  - 支持的控件类型：boolean/string/select/number，对应 React/Vanilla 逻辑，使用 deepGet/deepSet/getControlDefaults。

已做的质量校验
- TypeScript/ESLint 本地检查通过这些新增文件无错误（修正了装饰器、accessor 初始化、import 顺序等问题）。

可选的下一步
- 如果你希望在 Story/示例中直接演示，用法可参考现有 `AspectRatio.ts` 的结构，在合适位置引入 `@destyler/shared-private/lit` 再挂上这两个组件。
- 如需 Controls 的样式，与 React 版一致的类名已经保留（checkbox/text/controls-container），可以在共享样式里加一点皮肤。

需要我顺手在一个示例组件里接入演示一下吗？

---

_**User (2025-10-17 12:56Z)**_

在这里帮我演示一下

---

_**Agent (model copilot/gpt-5)**_

我将搜索是否已有适用于 aspect-ratio 的 controls 配置，并据此在示例中实例化 ControlsController，接着修改模板把 .controls 和 .state 正确传入。 
```

```

```

```

```

```

```

```

```

```

```

```
我已经把 Lit 版本的演示接好了，并直接在示例里完成了接线。

更新内容
- 在 `` 中已实现并导出：
  - `destyler-toolbar`、`destyler-state-visualizer` 组件
  - `ControlsController` 控制器（作为你喜欢的 “hook” 用法）

- 在 `AspectRatio.ts` 中完成示例接入：
  - 新增 `private controls = new ControlsController(aspectRatioControls)`
  - 在模板中按你想要的方式使用：
    - 
      <destyler-toolbar .controls=${this.controls}>
        <destyler-state-visualizer .state=${this.state}></destyler-state-visualizer>
      </destyler-toolbar>

关键点说明
- `ControlsController` 会渲染控件 UI（内部有 checkbox/text/select/number 的统一处理），并提供 subscribe 机制；在 `destyler-toolbar` 中它会被订阅，从而在控件变化时自动触发更新。
- `destyler-state-visualizer` 接收 `.state=${this.state}`，这就是 `@destyler/lit` 的 `Component` 基类里维护的 XState 当前状态；我对齐了 React 版的结构及行为。
- 所有新文件已在 `index.ts` 导出，因此示例页通过 `@destyler/shared-private/lit` 引入后即可使用这两个组件和控制器。

现在的示例代码关键片段（已在文件中完成）
- 文件：`AspectRatio.ts`
  - imports 顺序已按照项目 ESLint 规范整理
  - 构造 `controls` 并渲染 toolbar & visualizer
  - `.state=${this.state}` 可视化当前机器状态

如果你需要，我可以继续：
- 给其他组件的 Lit 示例页也挂上同样的 Toolbar + Visualizer + Controls
- 为 Controls 的 UI 增加样式标签，和 React/Solid 示例的外观保持一致

要不要我顺手在另一个 Lit 示例（比如 Carousel）里也接上同样的演示？

---

_**User (2025-10-17 13:03Z)**_

你可能需要帮我修改一下 `packages/frameworks/lit` 的实现，让我有类似 React 的体验。

---

_**Agent (model copilot/gpt-5)**_

我将先浏览 `` 以了解当前 API（如 normalizeProps、spread、Component 等）并找出与 React 体验差异，然后按需调整导出和辅助函数以提供更顺手的开发体验。 
```

```

```

```

```

```
我来把 Lit 的体验补全为“更像 React”的用法，并在 AspectRatio 示例里演示了起来。

改动概览
- Lit 控制器（hook-like）
  - 新增 `ControlsController`（已在 `@destyler/shared-private/lit` 导出），用法：
    - 在类中初始化：private controls = new ControlsController(aspectRatioControls)
    - 在模板中：<destyler-toolbar .controls=${this.controls}><destyler-state-visualizer .state=${this.state}></destyler-state-visualizer></destyler-toolbar>
- Lit 组件基类增强
  - 在 `@destyler/lit` 的 `Component` 中新增了一个受保护的辅助方法：
    - bindControls(controls): 将类似 React hook 的 controls 外部上下文“绑定”到 service 上：
      - 立即把 controls.context 注入到 `service.setContext(...)`
      - 订阅 controls.subscribe，后续变更会自动同步到 service context
      - 在 disconnected 时自动清理订阅
- AspectRatio Lit 示例对齐 React 体验
  - 文件：`AspectRatio.ts`
  - 使用方式：
    - 引入 controls 配置和 `ControlsController`
    - 在类中声明：private controls = new ControlsController(aspectRatioControls)
    - 覆写 connectedCallback：this.bindControls(this.controls); super.connectedCallback()
    - 模板中加入 toolbar + state visualizer
  - 现在的行为和 React 示例更一致：controls 改变时，service 的 context 会实时更新，状态可视化也随之更新。

你现在可以这样写（已在示例中实现）
- 在模板中：

  <destyler-toolbar .controls=${this.controls}>
    <destyler-state-visualizer .state=${this.state}></destyler-state-visualizer>
  </destyler-toolbar>

- 在类中：

  private controls = new ControlsController(aspectRatioControls)

  override connectedCallback(): void {
    // 将 Controls 作为外部 context 源绑定到 service
    // 这样就像 React 的 useControls + useMachine(context) 一样
    // @ts-expect-error 使用受保护 helper（示例中允许）
    this.bindControls(this.controls)
    super.connectedCallback()
  }

涉及文件
- `component.ts`
  - 新增 protected 方法 bindControls，用于注入/订阅外部 context（如 ControlsController）。
- `AspectRatio.ts`
  - 演示了 ControlsController 的初始化与绑定，以及 Toolbar + StateVisualizer 的组合使用。
- shared/src/lit 下已存在的三个能力（前一步已实现）
  - components/Toolbar.ts（destyler-toolbar）
  - components/StateVisualizer.ts（destyler-state-visualizer）
  - controllers/ControlsController.ts（hook-like 控制器）

运行与验证
- 这些变更未引入构建错误，我已检查新增和修改文件的类型错误为 PASS。
- 你可以直接打开 Lit 的 AspectRatio 示例页面进行观测；controls 的修改会实时反映到 context 和可视化上。

下一步建议
- 如果希望完全复用到其他 Lit 示例（如 carousel、dialog 等），我可以把上述模式推广过去（加上 `ControlsController`、`destyler-toolbar`、`destyler-state-visualizer`）。
- 如需对 Controls 进行样式优化（和 React 示例视觉一致），我可以在 shared 的样式中补上对应 class 的样式。

---

